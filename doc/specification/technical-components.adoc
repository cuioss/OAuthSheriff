= JWT Token Handling Technical Components
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

xref:../Specification.adoc[Back to Main Specification]

== Overview
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-1[OAUTH-SHERIFF-1: Token Parsing and Validation]_

This document provides detailed specifications for the technical components of the JWT Token Validation library.

=== Document Navigation

* xref:../../README.adoc[README] - Project overview and introduction
* xref:../../oauth-sheriff-core/README.adoc[Usage Guide] - How to use the library with code examples
* xref:../Requirements.adoc[Requirements] - Functional and non-functional requirements
* xref:../Specification.adoc[Specification] - Technical specifications
* xref:../LogMessages.adoc[Log Messages] - Reference for all log messages
* xref:../Build.adoc[Building and Development] - Information for contributors
* xref:../security/security-specifications.adoc[Security] - Security measures implementation
* xref:testing.adoc[Testing] - Testing approach and coverage
* xref:token-size-validation.adoc[Token Size Validation] - Token size validation details
* xref:token-decryption.adoc[Token Decryption] - Future JWE support

== Component Specifications

=== TokenValidator
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-2[OAUTH-SHERIFF-2: Token Representation]_

==== Status: IMPLEMENTED

This specification has been implemented in the following classes:

* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/TokenValidator.java[TokenValidator] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/ParserConfig.java[ParserConfig] (configuration)

The `TokenValidator` is the primary entry point for applications using the library. It provides methods for creating and validating different types of tokens (access, ID, refresh) while handling the complexity of token parsing and validation through a pipeline approach.

The `TokenValidator` uses a pipeline of validators and builders to process tokens:

1. `TokenHeaderValidator` - Validates token headers (algorithm, key ID, embedded JWK protection, optional token type per RFC 9068)
2. `TokenSignatureValidator` - Validates token signatures using JWKS
3. `TokenBuilder` - Creates token content objects
4. `TokenClaimValidator` - Validates token claims (expiration, audience, etc.)
5. `DpopProofValidator` - Validates DPoP proof JWTs per RFC 9449 (optional, per-issuer)

For implementation details, see the JavaDoc of the xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/TokenValidator.java[TokenValidator] class.

The following tests verify the implementation:

* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/TokenValidatorTest.java[TokenValidatorTest]

=== Token Validation Pipeline
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-1.3[OAUTH-SHERIFF-1.3: Signature Validation]_

==== Status: IMPLEMENTED

This specification has been implemented in the following classes:

* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenHeaderValidator.java[TokenHeaderValidator] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidator.java[TokenSignatureValidator] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/TokenBuilder.java[TokenBuilder] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenClaimValidator.java[TokenClaimValidator] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/NonValidatingJwtParser.java[NonValidatingJwtParser] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/dpop/DpopProofValidator.java[DpopProofValidator] (class)

Each component in the pipeline has a specific responsibility:

* `TokenHeaderValidator` - Validates token headers (algorithm, key ID, embedded JWK protection, optional token type per RFC 9068)
* `TokenSignatureValidator` - Validates token signatures using JWKS
* `TokenBuilder` - Creates token content objects
* `TokenClaimValidator` - Validates token claims (expiration, audience, etc.)
* `DpopProofValidator` - Validates DPoP (Demonstrating Proof of Possession) proof JWTs per https://datatracker.ietf.org/doc/html/rfc9449[RFC 9449]. Optional per-issuer. Validates proof structure, signature, JWK Thumbprint binding (https://datatracker.ietf.org/doc/html/rfc7638[RFC 7638]), access token hash (`ath`), freshness (`iat`), and jti replay prevention.
* `NonValidatingJwtParser` - Provides initial token decoding without validation

This pipeline approach provides several benefits:

* Better separation of concerns
* More flexible validation process
* Improved error handling and reporting through exception-based validation
* Enhanced security through comprehensive validation
* Clear error signaling with structured exception information

For implementation details, see the JavaDoc of the pipeline component classes.

The following tests verify the implementation:

* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenHeaderValidatorTest.java[TokenHeaderValidatorTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidatorTest.java[TokenSignatureValidatorTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/TokenBuilderTest.java[TokenBuilderTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenClaimValidatorTest.java[TokenClaimValidatorTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/NonValidatingJwtParserTest.java[NonValidatingJwtParserTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/dpop/DpopProofValidatorTest.java[DpopProofValidatorTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/dpop/DpopReplayProtectionTest.java[DpopReplayProtectionTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/util/JwkThumbprintUtilTest.java[JwkThumbprintUtilTest]

=== Exception-based Validation
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-1[OAUTH-SHERIFF-1: Token Parsing and Validation]_

==== Status: IMPLEMENTED

This specification has been implemented in the following classes:

* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/exception/TokenValidationException.java[TokenValidationException] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/security/SecurityEventCounter.java[SecurityEventCounter] (integration)

The validation pipeline uses an exception-based approach for error handling. Instead of returning Optional objects, the validation methods return the validated object directly and throw a TokenValidationException on validation failure.

The TokenValidationException is a runtime exception that encapsulates:

* EventType - The type of security event that caused the validation failure
* EventCategory - The category of the validation failure (InvalidStructure, InvalidSignature, or SemanticIssues)
* A detailed error message

==== Event Categories

The EventCategory is integrated into SecurityEventCounter.EventType and covers the following categories:

* InvalidStructure: For malformed tokens, size violations, etc. (typically thrown by NonValidatingJwtParser or TokenHeaderValidator). Usually maps to HTTP 401.
* InvalidSignature: For signature verification failures (typically thrown by TokenSignatureValidator). Usually maps to HTTP 401.
* SemanticIssues: For semantic validation failures (typically thrown by TokenClaimValidator, e.g., time or audience issues). Usually maps to HTTP 401.

This approach provides several benefits:

* Clearer error signaling and propagation
* Richer error context for diagnostics and logging
* Improved integration with HTTP APIs and exception mappers
* More idiomatic and maintainable code

For implementation details, see the JavaDoc of the xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/exception/TokenValidationException.java[TokenValidationException] class.

=== IssuerConfig and Multi-Issuer Support
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-3[OAUTH-SHERIFF-3: Multi-Issuer Support]_

==== Status: IMPLEMENTED

This specification has been implemented in the following classes:

* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/IssuerConfig.java[IssuerConfig] (class)

Each IssuerConfig instance contains all the information needed to validate tokens from a specific issuer:

* **Issuer Identifier** (`issuerIdentifier`) - Required for all JWKS loading variants except well-known discovery
* **Expected audience values** - Used for audience claim validation
* **Expected client ID values** - Used for authorized party claim validation
* **JWKS configuration** (one of the following):
** HTTP JWKS configuration (httpJwksLoaderConfig) - supports both direct HTTP endpoints and well-known discovery
** File path to JWKS file (jwksFilePath) - requires explicit issuerIdentifier
** In-memory JWKS content (jwksContent) - requires explicit issuerIdentifier
* **Algorithm preferences** - Specifies allowed signature algorithms
* **Custom claim mappers** - For custom claim processing

==== Issuer Identification Strategy

The IssuerConfig supports a sophisticated issuer identification strategy that distinguishes between different JWKS loading methods:

* **Well-Known Discovery**: The issuer identifier is automatically extracted from the OpenID Connect discovery document
* **Direct HTTP/File/In-Memory**: The issuer identifier must be explicitly configured via the `issuerIdentifier` field

The resolution logic prioritizes dynamic identification over static configuration:

[source,java]
----
public Optional<String> getIssuerIdentifier() {
    // First try to get issuer identifier from JwksLoader (for well-known discovery)
    if (jwksLoader != null && jwksLoader.getLoaderStatus() == LoaderStatus.OK) {
        Optional<String> jwksLoaderIssuer = jwksLoader.getIssuerIdentifier();
        if (jwksLoaderIssuer.isPresent()) {
            return jwksLoaderIssuer;
        }
    }

    // Fall back to configured issuer identifier (for file-based, in-memory, etc.)
    return Optional.ofNullable(issuerIdentifier);
}
----

==== Configuration Validation and Initialization

The IssuerConfig follows a two-phase approach separating configuration validation from JwksLoader initialization:

===== Phase 1: Configuration Validation (Built into Build Process)

Configuration validation is automatically performed during the `build()` method via a custom builder:

[source,java]
----
IssuerConfig config = IssuerConfig.builder()
    .issuerIdentifier("https://my-issuer.com")
    .jwksContent(jwksContent)
    .build();  // ✅ Validation happens automatically during build
----

**Validation Rules (enforced during build):**

* At least one JWKS loading method must be configured for enabled issuers
* `issuerIdentifier` is required for file-based and in-memory JWKS loading
* `issuerIdentifier` is optional for well-known discovery (extracted from discovery document)
* `issuerIdentifier` is required for custom JwksLoaders unless they provide their own identifier

===== Phase 2: JwksLoader Initialization

The `initJWKSLoader()` method handles pure initialization:

[source,java]
----
// Later, when SecurityEventCounter is available
config.initJWKSLoader(securityEventCounter);  // ✅ Pure initialization
----

**Initialization Process:**

* Creates appropriate JwksLoader instances based on configuration
* Passes the SecurityEventCounter to all JwksLoader implementations
* Assumes configuration has already been validated during construction
* Focuses solely on resource initialization, not validation

This separation provides several benefits:

* **Automatic Validation**: Configuration errors are caught immediately during object construction
* **Clear Semantics**: Configuration validation is separate from resource initialization
* **Fail-Fast Behavior**: Invalid configurations are rejected before they can be used
* **Better Developer Experience**: No need to remember to call separate validation methods
* **Simplified Initialization**: The initialization method focuses only on creating JwksLoader instances

The TokenValidator manages multiple IssuerConfig instances, ensures they are validated, initializes them with SecurityEventCounter, and selects the appropriate configuration for token validation.

==== Multi-Issuer Architecture

The module provides robust support for multi-issuer environments through:

image::../../doc/plantuml/multi-issuer-support.png[Multi-Issuer Support]

* Configuration of multiple issuers with IssuerConfig objects
* Automatic issuer detection and validation
* Thread-safe token validation

==== Key Management

image::../../doc/plantuml/key-management.png[Key Management]

The key management system handles the retrieval, caching, and rotation of cryptographic keys used for token validation.

For implementation details, see the JavaDoc of the xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/IssuerConfig.java[IssuerConfig] class.

The following tests verify the implementation:

* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/IssuerConfigTest.java[IssuerConfigTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/TokenValidatorTest.java[TokenValidatorTest]

=== JwksLoader
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-4[OAUTH-SHERIFF-4: Key Management]_

==== Status: IMPLEMENTED

This specification has been implemented in the following classes:

* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/JwksLoader.java[JwksLoader] (interface)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/http/HttpJwksLoader.java[HttpJwksLoader] (implementation)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/key/JWKSKeyLoader.java[JWKSKeyLoader] (implementation)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/JwksLoaderFactory.java[JwksLoaderFactory] (factory)

The `JwksLoader` interface handles the retrieval, caching, and rotation of cryptographic keys used for token validation. It also provides issuer identification capabilities for well-known discovery scenarios. The `JWKSKeyLoader` class is used by the TokenSignatureValidator to validate token signatures. All implementations integrate with the SecurityEventCounter to track security events related to key management.

==== Async-First Internal Architecture

The JwksLoader implementations use an async-first architecture internally, powered by the CUI-HTTP library's HttpAdapter composition pattern:

* **HttpAdapter Composition**: `HttpJwksLoader` uses `ETagAwareHttpAdapter` for bandwidth-efficient caching combined with `ResilientHttpAdapter` for resilient retry behavior
* **CompletableFuture-Based**: The `initJWKSLoader()` method returns `CompletableFuture<LoaderStatus>` for asynchronous initialization
* **Thread-Safe**: Lock-free implementation using `AtomicReference` for status tracking and content management
* **Background Refresh**: Automatic background refresh of JWKS content with configurable intervals

**Important**: While the internal implementation is async-first, the public-facing TokenValidator API remains synchronous. The async operations are resolved internally using `.join()` to provide a simple, blocking API for common use cases.

==== Core Methods

The JwksLoader interface provides the following core methods:

* **Key Management**: `getKeyInfo()`, `getFirstKeyInfo()`, `getAllKeyInfos()`, `keySet()`
* **Health Monitoring**: `getLoaderStatus()`
* **Type Information**: `getJwksType()`
* **Issuer Identification**: `getIssuerIdentifier()` - NEW: Returns the issuer identifier when available

==== Issuer Identification Support

The `getIssuerIdentifier()` method enables dynamic issuer identification:

* **HttpJwksLoader**: Returns the issuer identifier from OpenID Connect discovery documents when using well-known endpoints
* **JWKSKeyLoader**: Returns empty (in-memory and file-based loaders don't have associated issuer identifiers)
* **Integration**: Used by IssuerConfig.getEffectiveIssuer() to provide authoritative issuer identification

Example:
[source,java]
----
// HTTP loader with well-known discovery automatically provides issuer
HttpJwksLoaderConfig config = HttpJwksLoaderConfig.builder()
    .wellKnownUrl("https://example.com/.well-known/openid-configuration")
    .build();
JwksLoader loader = JwksLoaderFactory.createHttpLoader(config, eventCounter);

// Issuer identifier is extracted from discovery document
Optional<String> issuer = loader.getIssuerIdentifier();
----

==== Key Rotation Grace Period
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-4.5[OAUTH-SHERIFF-4.5: Key Rotation Grace Period]_

The `HttpJwksLoader` implements a configurable grace period for retired keys during rotation:

* **Grace Period Configuration**: Default 5 minutes, configurable via `HttpJwksLoaderConfig.keyRotationGracePeriod`
* **Zero Grace Period**: Setting to `Duration.ZERO` immediately invalidates old keys
* **Retired Key Management**: Maintains a bounded queue of retired key sets with timestamps
* **Automatic Cleanup**: Expired keys beyond the grace period are automatically removed
* **Content Change Detection**: Prevents unnecessary rotation when JWKS content hasn't changed (Issue #110)

Implementation Details:
[source,java]
----
HttpJwksLoaderConfig config = HttpJwksLoaderConfig.builder()
    .jwksUrl("https://example.com/.well-known/jwks.json")
    .keyRotationGracePeriod(Duration.ofMinutes(5))  // Default grace period
    .maxRetiredKeySets(10)                          // Max retained sets
    .build();
----

The grace period ensures tokens signed with recently rotated keys remain valid during the transition, preventing service disruptions for in-flight requests.

==== ETag Caching Behavior

The `HttpJwksLoader` implements efficient ETag-based caching to minimize bandwidth usage:

* **ETag Support**: Automatically includes `If-None-Match` headers on subsequent requests
* **304 Not Modified**: Server returns 304 when content hasn't changed, avoiding data transfer
* **Cache Key Strategy**: Uses URI-only cache keys (via `CacheKeyHeaderFilter.NONE`) since JWKS endpoints are public OAuth endpoints
* **Thread-Safe Cache**: Lock-free cache operations using atomic references
* **Background Refresh Integration**: Background refresh tasks correctly handle 304 responses by skipping key updates

Example behavior:
[source]
----
First request:  → 200 OK with full JWKS content + ETag: "abc123"
Second request: → 304 Not Modified (cached content reused)
Third request:  → 304 Not Modified (cached content reused)
After key rotation: → 200 OK with new JWKS content + ETag: "def456"
----

This implementation significantly reduces network traffic and server load while ensuring keys are always up-to-date.

==== HttpAdapter Composition Pattern

The internal architecture of `HttpJwksLoader` and `HttpWellKnownResolver` follows a clean composition pattern using CUI-HTTP library adapters:

**Base Layer - ETag Caching:**
[source,java]
----
HttpAdapter<Jwks> base = ETagAwareHttpAdapter.<Jwks>builder()
    .httpHandler(httpHandler)
    .responseConverter(converter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // URI-only for public endpoints
    .build();
----

**Decorator Layer - Resilient Retry:**
[source,java]
----
HttpAdapter<Jwks> adapter = ResilientHttpAdapter.wrap(base, retryConfig);
----

**Benefits:**
* Separation of concerns (caching vs. retry logic)
* Composable and testable architecture
* ETag caching can be independently configured
* Retry behavior can be customized via `RetryConfig`

**Synchronous API Design:**
Public API methods remain synchronous by calling `.join()` on the `CompletableFuture` returned by `adapter.get()`:
[source,java]
----
// Internal async operation, public sync API
HttpResult<Jwks> result = adapter.get().join();
----

==== JwksLoaderFactory

The JwksLoaderFactory provides methods to create different types of JwksLoader implementations:

* `createHttpLoader` - Creates an HTTP-based loader that fetches keys from a remote endpoint
* `createFileLoader` - Creates a file-based loader that reads keys from a local file
* `createInMemoryLoader` - Creates an in-memory loader that uses a provided JWKS string

Each method requires a SecurityEventCounter parameter to track security events.

For implementation details, see the JavaDoc of the following classes:

* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/JwksLoader.java[JwksLoader]
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/http/HttpJwksLoader.java[HttpJwksLoader]
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/key/JWKSKeyLoader.java[JWKSKeyLoader]
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/JwksLoaderFactory.java[JwksLoaderFactory]

==== LoadingStatusProvider and LoaderStatus

OAuth-Sheriff provides health status infrastructure for loader components through the `LoadingStatusProvider` interface and `LoaderStatus` enum.

**LoadingStatusProvider Interface:**

Interface for components providing health status information in OAuth/JWT validation.

[source,java]
----
package de.cuioss.sheriff.oauth.core.util;

public interface LoadingStatusProvider {
    LoaderStatus getLoaderStatus();
    default boolean isLoaderStatusOK() { ... }
}
----

**Implementations:**

* `JwksLoader` - JWKS key loading status
* `HttpWellKnownResolver` - Well-known configuration status
* `IssuerConfig` - Aggregated issuer configuration status

**LoaderStatus Enum:**

Status values for loader operations:

* `UNDEFINED` - Initial state, not yet loaded
* `LOADING` - Load operation in progress
* `OK` - Successfully loaded and operational
* `ERROR` - Load failed with non-recoverable error

**Note:** These types provide health status infrastructure for OAuth/JWT validation components. All implementations must be non-blocking and avoid I/O operations in status checks.

The following tests verify the implementation:

* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/jwks/http/HttpJwksLoaderTest.java[HttpJwksLoaderTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/jwks/http/HttpJwksLoaderGracePeriodTest.java[HttpJwksLoaderGracePeriodTest] - Verifies grace period functionality (Requirement OAUTH-SHERIFF-4.5)
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/jwks/FileJwksLoaderTest.java[FileJwksLoaderTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/jwks/InMemoryJwksLoaderTest.java[InMemoryJwksLoaderTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/jwks/key/JWKSKeyLoaderTest.java[JWKSKeyLoaderTest]

=== SecurityEventCounter
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-7.3[OAUTH-SHERIFF-7.3: Security Events]_

==== Status: IMPLEMENTED

This specification has been implemented in the following classes:

* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/security/SecurityEventCounter.java[SecurityEventCounter] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/TokenValidator.java[TokenValidator] (integration)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/IssuerConfig.java[IssuerConfig] (integration)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/JwksLoaderFactory.java[JwksLoaderFactory] (integration)

The `SecurityEventCounter` provides a thread-safe mechanism for counting security events that occur during token processing. It is created by the TokenValidator and passed to all components in the token validation pipeline, including:

* TokenHeaderValidator
* TokenSignatureValidator
* TokenClaimValidator
* JwksLoader implementations

The counter follows the same naming/numbering scheme as JWTTokenLogMessages for consistency and easier correlation between logs and metrics. It is designed to be highly concurrent and provides methods for:

* Incrementing event counters
* Getting counts for specific event types
* Getting a snapshot of all counters
* Resetting individual or all counters

The implementation is structured to simplify later integration with metrics systems like Micrometer but does not create any dependency on it.

For implementation details, see the JavaDoc of the xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/security/SecurityEventCounter.java[SecurityEventCounter] class.

The following tests verify the implementation:

* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/SecurityEventCounterTest.java[SecurityEventCounterTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/TokenValidatorSecurityEventTest.java[TokenValidatorSecurityEventTest]

=== TokenValidatorMonitor

==== Status: IMPLEMENTED

This specification has been implemented in the following classes:

* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/metrics/TokenValidatorMonitor.java[TokenValidatorMonitor] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/metrics/MeasurementType.java[MeasurementType] (enum)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/TokenValidator.java[TokenValidator] (integration)

The `TokenValidatorMonitor` provides high-performance, thread-safe monitoring of JWT validation pipeline metrics. It measures execution times for different stages of JWT validation with microsecond precision and maintains a configurable rolling window of recent measurements.

==== Key Features

* **Thread-Safe**: All operations are lock-free using atomic operations
* **Zero Runtime Impact**: Optimized for minimal overhead during measurement
* **Microsecond Precision**: All measurements recorded in microseconds
* **Rolling Window**: Maintains configurable number of recent samples (default: 100)
* **Pipeline Aware**: Measures each validation step separately

==== Measurement Types

The monitor tracks the following pipeline steps:

* `COMPLETE_VALIDATION` - Complete token validation from start to finish
* `TOKEN_PARSING` - JWT token parsing and structure validation
* `HEADER_VALIDATION` - JWT header validation
* `SIGNATURE_VALIDATION` - JWT signature verification (typically most expensive)
* `CLAIMS_VALIDATION` - JWT claims validation
* `JWKS_OPERATIONS` - JWKS key retrieval and processing operations

==== Integration with Micrometer

In Quarkus environments, the performance metrics are automatically exposed as Micrometer timers through the `JwtMetricsCollector`:

* **Metric Name**: `sheriff.oauth.validation.duration`
* **Tags**: `step` (measurement type in lowercase)
* **Description**: Duration of JWT validation pipeline steps

For implementation details, see the JavaDoc of the xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/metrics/TokenValidatorMonitor.java[TokenValidatorMonitor] class.

The following tests verify the implementation:

* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/metrics/TokenValidatorMonitorTest.java[TokenValidatorMonitorTest]
* xref:../../oauth-sheriff-quarkus-parent/oauth-sheriff-quarkus/src/test/java/de/cuioss/sheriff/oauth/quarkus/metrics/JwtMetricsCollectorTest.java[JwtMetricsCollectorTest] (Quarkus integration)

=== Token Architecture and Types
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-1.2[OAUTH-SHERIFF-1.2: Token Types]_

==== Status: IMPLEMENTED

This specification has been implemented in the following classes:

* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/TokenContent.java[TokenContent] (interface)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/BaseTokenContent.java[BaseTokenContent] (abstract class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/MinimalTokenContent.java[MinimalTokenContent] (interface)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/AccessTokenContent.java[AccessTokenContent] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/IdTokenContent.java[IdTokenContent] (class)
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/RefreshTokenContent.java[RefreshTokenContent] (class)

==== Architecture

The module uses a flexible architecture based on inheritance and composition:

image::../../doc/plantuml/token-types.png[Token Types]

* `TokenContent`: Core interface defining JWT token functionality
* `BaseTokenContent`: Abstract base class implementing common token functionality
* `MinimalTokenContent`: Minimal interface for tokens without claims

==== Token Types

The module supports three token types, each with specific functionality:

* `AccessTokenContent`: OAuth2 access token with scope and role support
** Extends BaseTokenContent for common token functionality
** Provides enhanced scope and role management
** Supports email and preferred username claims
* `IdTokenContent`: OpenID Connect ID token for user identity
** Extends BaseTokenContent for common token functionality
** Focuses on identity information claims
** Provides access to name and email claims
* `RefreshTokenContent`: OAuth2 refresh token
** Implements MinimalTokenContent interface
** Treats refresh tokens as opaque strings per OAuth2 specification
** In case it is a JWT, the corresponding claims will be extracted and made available.
*Caution:* The signature of the refresh token is not verified, so the claims should be treated as untrusted.


The library provides specialized classes for different token types, each with functionality appropriate for its use case.

`AccessTokenContent` and `IdTokenContent` extend the `BaseTokenContent` abstract class, which implements the `TokenContent` interface. This provides a common base for token functionality while allowing for type-specific extensions.

`RefreshTokenContent` implements the `MinimalTokenContent` interface and provides functionality for handling refresh tokens, which are treated primarily as opaque strings according to OAuth2 specifications.

For implementation details, see the JavaDoc of the following classes:

* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/TokenContent.java[TokenContent]
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/BaseTokenContent.java[BaseTokenContent]
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/MinimalTokenContent.java[MinimalTokenContent]
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/AccessTokenContent.java[AccessTokenContent]
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/IdTokenContent.java[IdTokenContent]
* xref:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/domain/token/RefreshTokenContent.java[RefreshTokenContent]

The following tests verify the implementation:

* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/domain/token/AccessTokenContentTest.java[AccessTokenContentTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/domain/token/IdTokenContentTest.java[IdTokenContentTest]
* xref:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/domain/token/RefreshTokenContentTest.java[RefreshTokenContentTest]

=== Dependency Management
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8[OAUTH-SHERIFF-8: Security]_

==== Status: IMPLEMENTED

The library implements automated dependency management to ensure that dependencies are kept up-to-date with the latest security patches and bug fixes. This is implemented using GitHub Dependabot, which is configured to scan Maven dependencies weekly and create pull requests for updates.

The Dependabot configuration can be found in `.github/dependabot.yml` and includes:

* Weekly scanning of Maven dependencies
* Automatic creation of pull requests for dependency updates
* Prioritization of security updates

This implementation ensures that the library's dependencies are regularly updated to their latest stable versions, reducing security vulnerabilities and ensuring access to the latest features.
